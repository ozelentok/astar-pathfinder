// Generated by CoffeeScript 1.6.3
(function() {
  var AS, astarPathfinder;

  AS = {};

  AS.Pathfinder = (function() {
    var Const;

    Const = {
      width: 700,
      squares: 100
    };

    Const.height = Const.width;

    Const.squareLen = Const.width / Const.squares;

    function Pathfinder($canvas) {
      this.canvas = $canvas[0];
      this.ctx = this.canvas.getContext('2d');
      this.setSizes();
      this.setEvents();
      this.initData();
      this.drawAll();
    }

    Pathfinder.prototype.initData = function() {
      this.buildGrid();
      this.start = {
        x: 0,
        y: 0
      };
      this.goal = {
        x: Const.squares - 1,
        y: Const.squares - 1
      };
    };

    Pathfinder.prototype.Astar = function() {
      this.closedSet = {};
      this.openSet = new BinaryHeap(function(node) {
        return node.fScore;
      });
      this.start.gScore = this.grid[this.start.x][this.start.y];
      this.start.fScore = this.start.gScore + this.heuristic_cost(this.start, this.goal);
      this.addToOpenSet(this.start);
    };

    Pathfinder.prototype.AstarLoop = function() {
      var current;
      if (this.openSet.size() >= 1) {
        current = this.openSet.pop();
        if (this.hasReachedGoal(current)) {
          return false;
        }
        this.addToClosedSet(current);
        this.checkNeighbors(current);
        return true;
      } else {
        console.log("failure");
        return false;
      }
    };

    Pathfinder.prototype.hasReachedGoal = function(current) {
      if (current.x === this.goal.x && current.y === this.goal.y) {
        this.drawAll();
        this.drawPath(current);
        this.enableButtons();
        console.log("win");
        return true;
      }
      return false;
    };

    Pathfinder.prototype.checkNeighbors = function(current) {
      var neighbor, tentativeGScore, _i, _len, _ref;
      _ref = this.neighborsOf(current);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        neighbor = _ref[_i];
        if (neighbor.gScore === 1001) {
          this.addToClosedSet(neighbor);
          continue;
        }
        if (this.isInClosedSet(neighbor)) {
          continue;
        }
        if (!this.isInOpenSet(neighbor)) {
          neighbor.gScore += current.gScore;
          this.addToOpenSet(neighbor);
        } else {
          tentativeGScore = current.gScore + this.grid[neighbor.x][neighbor.y];
          if (tentativeGScore < neighbor.gScore) {
            neighbor.dad = current;
            neighbor.gScore = tentativeGScore;
            neighbor.fScore = neighbor.gScore + this.heuristic_cost(neighbor, this.goal);
          }
        }
      }
    };

    Pathfinder.prototype.addToOpenSet = function(cell) {
      cell.fScore = cell.gScore + this.heuristic_cost(cell, this.goal);
      this.openSet.push(cell);
    };

    Pathfinder.prototype.addToClosedSet = function(cell) {
      var key;
      key = cell.x + '|' + cell.y;
      this.closedSet[key] = true;
    };

    Pathfinder.prototype.isInClosedSet = function(cell) {
      var key;
      key = cell.x + '|' + cell.y;
      return key in this.closedSet;
    };

    Pathfinder.prototype.isInOpenSet = function(cell) {
      var setCell, _i, _len, _ref;
      _ref = this.openSet.content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setCell = _ref[_i];
        if (setCell.x === cell.x && setCell.y === cell.y) {
          return true;
        }
      }
      return false;
    };

    Pathfinder.prototype.heuristic_cost = function(from, to) {
      var dx, dy;
      dx = Math.abs(from.x - to.x);
      dy = Math.abs(from.y - to.y);
      return 10 * Math.sqrt(dx * dx + dy * dy);
    };

    Pathfinder.prototype.neighborsOf = function(cell) {
      var bottom, left, neighbors, right, top, x, y;
      x = cell.x;
      y = cell.y;
      neighbors = [];
      left = cell.x > 0;
      right = cell.x < Const.squares - 1;
      top = cell.y > 0;
      bottom = cell.y < Const.squares - 1;
      if (left) {
        neighbors.push({
          x: x - 1,
          y: y,
          gScore: this.grid[x - 1][y],
          dad: cell
        });
      }
      if (right) {
        neighbors.push({
          x: x + 1,
          y: y,
          gScore: this.grid[x + 1][y],
          dad: cell
        });
      }
      if (top) {
        neighbors.push({
          x: x,
          y: y - 1,
          gScore: this.grid[x][y - 1],
          dad: cell
        });
      }
      if (bottom) {
        neighbors.push({
          x: x,
          y: y + 1,
          gScore: this.grid[x][y + 1],
          dad: cell
        });
      }
      if (this.diagonals) {
        if (left && top) {
          neighbors.push({
            x: x - 1,
            y: y - 1,
            gScore: this.grid[x - 1][y - 1],
            dad: cell
          });
        }
        if (left && bottom) {
          neighbors.push({
            x: x - 1,
            y: y + 1,
            gScore: this.grid[x - 1][y + 1],
            dad: cell
          });
        }
        if (right && top) {
          neighbors.push({
            x: x + 1,
            y: y - 1,
            gScore: this.grid[x + 1][y - 1],
            dad: cell
          });
        }
        if (right && bottom) {
          neighbors.push({
            x: x + 1,
            y: y + 1,
            gScore: this.grid[x + 1][y + 1],
            dad: cell
          });
        }
      }
      return neighbors;
    };

    Pathfinder.prototype.buildGrid = function() {
      var i, j, _i, _ref;
      this.grid = [];
      for (i = _i = 1, _ref = Const.squares; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        this.grid.push((function() {
          var _j, _ref1, _results;
          _results = [];
          for (j = _j = 1, _ref1 = Const.squares; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
            _results.push(10);
          }
          return _results;
        })());
      }
      this.divideMaze(0, 0, Const.squares, Const.squares, 0, 0);
    };

    Pathfinder.prototype.decideOrientation = function(width, height) {
      if (width < height) {
        return 0;
      }
      if (height < width) {
        return 1;
      }
      return Math.floor(Math.random() * 2);
    };

    Pathfinder.prototype.divideMaze = function(x, y, width, height, orientaion) {
      var dx, dy, h, i, isHorizontal, len, nx, ny, val, w, wx, wy, _i;
      if (width < 4 || height < 6) {
        return;
      }
      isHorizontal = orientaion === 0;
      wx = x + (isHorizontal ? 0 : Math.floor(Math.random() * (width - 2)));
      wy = y + (isHorizontal ? Math.floor(Math.random() * (height - 2)) : 0);
      dx = isHorizontal ? 1 : 0;
      dy = isHorizontal ? 0 : 1;
      len = isHorizontal ? width : height;
      val = Math.floor(Math.random() * 1000);
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        this.grid[wx][wy] = val;
        wx += dx;
        wy += dy;
      }
      nx = x;
      ny = y;
      if (isHorizontal) {
        w = width;
        h = wy - y + 1;
      } else {
        w = wx - x + 1;
        h = height;
      }
      this.divideMaze(nx, ny, w, h, this.decideOrientation(w, h));
      if (isHorizontal) {
        nx = x;
        ny = wy + 1;
        w = width;
        h = y + height - wy - 1;
      } else {
        nx = wx + 1;
        ny = y;
        w = x + width - wx - 1;
        h = height;
      }
      this.divideMaze(nx, ny, w, h, this.decideOrientation(w, h));
    };

    Pathfinder.prototype.drawPath = function(currentCell) {
      currentCell = currentCell.dad;
      while (currentCell.dad) {
        this.drawCell(currentCell.x, currentCell.y, '#0F0');
        currentCell = currentCell.dad;
      }
    };

    Pathfinder.prototype.drawGrid = function() {
      var i, j, _i, _j, _ref, _ref1;
      for (i = _i = 0, _ref = Const.squares; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = Const.squares; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.drawCell(i, j, this.gToColor(this.grid[i][j]));
        }
      }
    };

    Pathfinder.prototype.gToColor = function(g) {
      var str;
      str = Math.floor(g * 255 / 1000).toString(16);
      return '#' + str + str + str;
    };

    Pathfinder.prototype.disableButtons = function() {
      $('button').attr('disabled', 'disabled');
    };

    Pathfinder.prototype.enableButtons = function() {
      $('button').removeAttr('disabled');
    };

    Pathfinder.prototype.drawCell = function(x, y, color) {
      this.ctx.fillStyle = color;
      this.ctx.fillRect(x * Const.squareLen, y * Const.squareLen, Const.squareLen, Const.squareLen);
    };

    Pathfinder.prototype.drawAll = function() {
      this.drawGrid();
      this.drawCell(this.start.x, this.start.y, '#22F');
      this.drawCell(this.goal.x, this.goal.y, '#F00');
    };

    Pathfinder.prototype.setSizes = function() {
      this.canvas.width = Math.min($(window).width() - 40, Const.width);
      this.canvas.height = Math.min($(window).width() - 40, Const.height);
      Const.squareLen = this.canvas.width / Const.squares;
    };

    Pathfinder.prototype.setEvents = function() {
      var _this = this;
      this.enableButtons();
      this.diagonals = true;
      $('#diagonal').prop('checked', this.diagonals);
      $(this.canvas).bind('mousedown', function(e) {
        var i, j;
        i = Math.floor((e.pageX - _this.canvas.offsetLeft) / Const.squareLen);
        j = Math.floor((e.pageY - _this.canvas.offsetTop) / Const.squareLen);
        if (e.which === 1) {
          _this.start.x = i;
          _this.start.y = j;
        } else if (e.which === 3) {
          _this.goal.x = i;
          _this.goal.y = j;
        } else {
          _this.grid[i][j] += 200;
          if (_this.grid[i][j] > 1000) {
            _this.grid[i][j] = 1000;
          }
        }
        _this.drawAll();
        return false;
      });
      $(this.canvas).bind('contextmenu', function() {
        return false;
      });
      $('#instantSolve').bind('click', function() {
        _this.disableButtons();
        _this.Astar();
        while (_this.AstarLoop()) {}
        _this.enableButtons();
      });
      $('#diagonal').bind('click', function(ev) {
        _this.diagonals = ev.currentTarget.checked;
        return true;
      });
      $(window).resize(function() {
        _this.setSizes();
        _this.drawAll();
      });
    };

    return Pathfinder;

  })();

  astarPathfinder = new AS.Pathfinder($('#simview'));

}).call(this);
