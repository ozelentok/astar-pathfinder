// Generated by CoffeeScript 1.6.3
(function() {
  var GE, germSim;

  GE = {};

  GE.Sim = (function() {
    var Const;

    Const = {
      width: 600,
      squares: 15
    };

    Const.height = Const.width;

    Const.squareLen = Const.width / Const.squares;

    function Sim($canvas) {
      this.canvas = $canvas[0];
      this.ctx = this.canvas.getContext('2d');
      this.setSizes();
      this.setEvents();
      this.buildGrid();
      this.start = {
        x: 0,
        y: 0
      };
      this.goal = {
        x: 10,
        y: 10
      };
      this.drawAll();
      this.enableButtons();
    }

    Sim.prototype.Astar = function() {
      this.closedSet = {};
      this.openSet = [];
      this.came_from = [];
      this.start.gScore = 1;
      this.start.fScore = this.start.gScore + this.heuristic_cost(this.start, this.goal);
      this.addToOpenSet(this.start);
      return this.disableButtons();
    };

    Sim.prototype.AstarLoop = function() {
      var current;
      if (this.openSet.length >= 1) {
        current = this.openSet[0];
        this.drawAll();
        this.drawCell(current.x * Const.squareLen, current.y * Const.squareLen, '#0F0');
        if (current.x === this.goal.x && current.y === this.goal.y) {
          this.drawAll();
          this.drawPath(current);
          console.log("win");
          clearInterval(this.timerId);
          this.enableButtons();
          return false;
        }
        this.openSet.splice(0, 1);
        this.addToClosedSet(current);
        this.checkNeighbors(current);
        this.drawFandG();
        return true;
      } else {
        console.log("failure");
        clearInterval(this.timerId);
        return false;
      }
    };

    Sim.prototype.checkNeighbors = function(current) {
      var neighbor, notInOpenSet, tentativeGScore, _i, _len, _ref;
      _ref = this.neighborsOf(current);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        neighbor = _ref[_i];
        if (this.isInClosedSet(neighbor)) {
          continue;
        }
        notInOpenSet = !this.isInOpenSet(neighbor);
        if (notInOpenSet) {
          neighbor.gScore += current.gScore;
          this.addToOpenSet(neighbor);
        } else {
          tentativeGScore = current.gScore + this.grid[neighbor.x][neighbor.y];
          if (tentativeGScore < neighbor.gScore) {
            neighbor.dad = current;
            neighbor.gScore = tentativeGScore;
            neighbor.fScore = neighbor.gScore + this.heuristic_cost(neighbor, this.goal);
          }
        }
        this.openSet.sort(function(a, b) {
          return a.fScore - b.fScore;
        });
      }
    };

    Sim.prototype.addToOpenSet = function(cell) {
      cell.fScore = cell.gScore + this.heuristic_cost(cell, this.goal);
      this.openSet.push(cell);
    };

    Sim.prototype.isInOpenSet = function(cell) {
      var setCell, _i, _len, _ref;
      _ref = this.openSet;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setCell = _ref[_i];
        if (setCell.x === cell.x && setCell.y === cell.y) {
          return true;
        } else if (setCell.fScore >= cell.fScore) {
          return false;
        }
      }
      return false;
    };

    Sim.prototype.addToClosedSet = function(cell) {
      var key;
      key = cell.x + '|' + cell.y;
      this.closedSet[key] = true;
    };

    Sim.prototype.isInClosedSet = function(cell) {
      var key;
      key = cell.x + '|' + cell.y;
      return key in this.closedSet;
    };

    Sim.prototype.heuristic_cost = function(from, to) {
      var dx, dy;
      dx = Math.abs(from.x - to.x);
      dy = Math.abs(from.y - to.y);
      return Math.sqrt(dx * dx + dy * dy) * 10;
    };

    Sim.prototype.neighborsOf = function(cell) {
      var bottom, left, neighbors, right, top, x, y;
      x = cell.x;
      y = cell.y;
      neighbors = [];
      left = cell.x > 0;
      right = cell.x < Const.squares - 1;
      top = cell.y > 0;
      bottom = cell.y < Const.squares - 1;
      if (left) {
        neighbors.push({
          x: x - 1,
          y: y,
          gScore: this.grid[x - 1][y],
          dad: cell
        });
      }
      if (right) {
        neighbors.push({
          x: x + 1,
          y: y,
          gScore: this.grid[x + 1][y],
          dad: cell
        });
      }
      if (top) {
        neighbors.push({
          x: x,
          y: y - 1,
          gScore: this.grid[x][y - 1],
          dad: cell
        });
      }
      if (bottom) {
        neighbors.push({
          x: x,
          y: y + 1,
          gScore: this.grid[x][y + 1],
          dad: cell
        });
      }
      if (this.diagonals) {
        if (left && top) {
          neighbors.push({
            x: x - 1,
            y: y - 1,
            gScore: this.grid[x - 1][y - 1],
            dad: cell
          });
        }
        if (left && bottom) {
          neighbors.push({
            x: x - 1,
            y: y + 1,
            gScore: this.grid[x - 1][y + 1],
            dad: cell
          });
        }
        if (right && top) {
          neighbors.push({
            x: x + 1,
            y: y - 1,
            gScore: this.grid[x + 1][y - 1],
            dad: cell
          });
        }
        if (right && bottom) {
          neighbors.push({
            x: x + 1,
            y: y + 1,
            gScore: this.grid[x + 1][y + 1],
            dad: cell
          });
        }
      }
      return neighbors;
    };

    Sim.prototype.buildGrid = function() {
      var i, j, _i, _ref;
      this.grid = [];
      for (i = _i = 1, _ref = Const.squares; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        this.grid.push((function() {
          var _j, _ref1, _results;
          _results = [];
          for (j = _j = 1, _ref1 = Const.squares; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
            _results.push(10);
          }
          return _results;
        })());
      }
    };

    Sim.prototype.drawPath = function(currentCell) {
      currentCell = currentCell.dad;
      while (currentCell.dad) {
        this.drawCell(currentCell.x * Const.squareLen, currentCell.y * Const.squareLen, '#0F0');
        currentCell = currentCell.dad;
      }
    };

    Sim.prototype.drawGrid = function() {
      var i, j, _i, _j, _ref, _ref1;
      for (i = _i = 0, _ref = Const.squares; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = Const.squares; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.drawCell(i * Const.squareLen, j * Const.squareLen, this.gToColor(this.grid[i][j]));
        }
      }
    };

    Sim.prototype.gToColor = function(g) {
      var str;
      str = Math.floor(g * 255 / 1000).toString(16);
      return '#' + str + str + str;
    };

    Sim.prototype.drawCell = function(x, y, color) {
      this.ctx.fillStyle = color;
      this.ctx.fillRect(x, y, Const.squareLen, Const.squareLen);
    };

    Sim.prototype.drawAll = function() {
      this.ctx.strokeStyle = 'white';
      this.drawGrid();
      this.drawCell(this.start.x * Const.squareLen, this.start.y * Const.squareLen, '#22F');
      this.drawCell(this.goal.x * Const.squareLen, this.goal.y * Const.squareLen, '#F00');
    };

    Sim.prototype.drawFandG = function() {
      var openCell, _i, _len, _ref;
      this.ctx.fillStyle = 'white';
      _ref = this.openSet;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        openCell = _ref[_i];
        this.ctx.fillText(openCell.fScore.toFixed(2), openCell.x * Const.squareLen + 10, (openCell.y + 0.3) * Const.squareLen);
        this.ctx.fillText(openCell.gScore.toFixed(2), openCell.x * Const.squareLen + 10, (openCell.y + 0.7) * Const.squareLen);
      }
    };

    Sim.prototype.setSizes = function() {
      this.canvas.width = Math.min($(window).width() - 40, Const.width);
      this.canvas.height = Math.min($(window).width() - 40, Const.height);
      Const.squareLen = this.canvas.width / Const.squares;
    };

    Sim.prototype.disableButtons = function() {
      $('button').attr('disabled', 'disabled');
    };

    Sim.prototype.enableButtons = function() {
      $('button').removeAttr('disabled');
    };

    Sim.prototype.setEvents = function() {
      var _this = this;
      this.diagonals = true;
      $('#diagonal').prop('checked', this.diagonals);
      this.keyMode = 0;
      $(this.canvas).bind('mousedown', function(e) {
        var i, j;
        i = Math.floor((e.pageX - _this.canvas.offsetLeft) / Const.squareLen);
        j = Math.floor((e.pageY - _this.canvas.offsetTop) / Const.squareLen);
        if (_this.keyMode === 1) {
          _this.start.x = i;
          _this.start.y = j;
        } else if (_this.keyMode === 2) {
          _this.goal.x = i;
          _this.goal.y = j;
        } else if (_this.grid[i][j] < 800) {
          _this.grid[i][j] += 400;
        }
        _this.drawAll();
      });
      $(document).bind('keydown', function(e) {
        if (e.keyCode === 17) {
          _this.keyMode = 1;
        } else if (e.keyCode === 16) {
          _this.keyMode = 2;
        } else if (e.keyCode === 32) {
          _this.AstarLoop();
        }
      });
      $(document).bind('keyup', function() {
        return _this.keyMode = 0;
      });
      $('#start').bind('click', function() {
        _this.Astar();
      });
      $('#instantSolve').bind('click', function() {
        _this.Astar();
        while (_this.AstarLoop()) {}
      });
      $('#diagonal').bind('click', function(ev) {
        _this.diagonals = ev.currentTarget.checked;
        return true;
      });
      $(window).resize(function() {
        _this.setSizes();
        _this.drawAll();
      });
    };

    return Sim;

  })();

  germSim = new GE.Sim($('#simview'));

}).call(this);
