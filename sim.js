// Generated by CoffeeScript 1.6.3
(function() {
  var AS, astarPathfinder;

  AS = {};

  AS.Const = {
    width: 700,
    squares: 100
  };

  AS.Const.height = AS.Const.width;

  AS.Const.squareLen = AS.Const.width / AS.Const.squares;

  AS.Pathfinder = (function() {
    function Pathfinder($canvas) {
      this.canvas = $canvas[0];
      this.setSizes();
      this.setEvents();
      this.initData();
      this.painter.drawAll(this.start, this.goal);
    }

    Pathfinder.prototype.initData = function() {
      this.mapGenerator = new AS.MapGenerator();
      this.grid = [];
      this.mapGenerator.buildMap(this.grid);
      this.painter = new AS.Painter(this.grid, this.canvas.getContext('2d'));
      this.start = {
        x: 0,
        y: 0
      };
      this.goal = {
        x: AS.Const.squares - 1,
        y: AS.Const.squares - 1
      };
    };

    Pathfinder.prototype.AstarInit = function() {
      this.closedSet = {};
      this.openSet = new BinaryHeap(function(node) {
        return node.fScore;
      });
      this.start.gScore = this.grid[this.start.x][this.start.y];
      this.start.fScore = this.start.gScore + this.heuristic_cost(this.start, this.goal);
      this.addToOpenSet(this.start);
    };

    Pathfinder.prototype.AstarLoop = function() {
      var current;
      if (this.openSet.size() >= 1) {
        current = this.openSet.pop();
        if (this.hasReachedGoal(current)) {
          return false;
        }
        this.addToClosedSet(current);
        this.checkNeighbors(current);
        return true;
      } else {
        console.log("failure");
        return false;
      }
    };

    Pathfinder.prototype.hasReachedGoal = function(current) {
      if (current.x === this.goal.x && current.y === this.goal.y) {
        this.painter.drawSolution(this.start, this.goal, current);
        this.enableButtons();
        console.log("win");
        return true;
      }
      return false;
    };

    Pathfinder.prototype.checkNeighbors = function(current) {
      var neighbor, tentativeGScore, _i, _len, _ref;
      _ref = this.neighborsOf(current);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        neighbor = _ref[_i];
        if (this.isInClosedSet(neighbor)) {
          continue;
        }
        if (!this.isInOpenSet(neighbor)) {
          neighbor.gScore += current.gScore;
          this.addToOpenSet(neighbor);
        } else {
          tentativeGScore = current.gScore + this.grid[neighbor.x][neighbor.y];
          if (tentativeGScore < neighbor.gScore) {
            neighbor.dad = current;
            neighbor.gScore = tentativeGScore;
            neighbor.fScore = neighbor.gScore + this.heuristic_cost(neighbor, this.goal);
          }
        }
      }
    };

    Pathfinder.prototype.addToOpenSet = function(cell) {
      cell.fScore = cell.gScore + this.heuristic_cost(cell, this.goal);
      this.openSet.push(cell);
    };

    Pathfinder.prototype.addToClosedSet = function(cell) {
      var key;
      key = cell.x + '|' + cell.y;
      this.closedSet[key] = true;
    };

    Pathfinder.prototype.isInClosedSet = function(cell) {
      var key;
      key = cell.x + '|' + cell.y;
      return key in this.closedSet;
    };

    Pathfinder.prototype.isInOpenSet = function(cell) {
      var setCell, _i, _len, _ref;
      _ref = this.openSet.content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        setCell = _ref[_i];
        if (setCell.x === cell.x && setCell.y === cell.y) {
          return true;
        }
      }
      return false;
    };

    Pathfinder.prototype.heuristic_cost = function(from, to) {
      var dx, dy;
      dx = Math.abs(from.x - to.x);
      dy = Math.abs(from.y - to.y);
      return 10 * Math.sqrt(dx * dx + dy * dy);
    };

    Pathfinder.prototype.neighborsOf = function(cell) {
      var bottom, left, neighbors, right, top, x, y;
      x = cell.x;
      y = cell.y;
      neighbors = [];
      left = cell.x > 0;
      right = cell.x < AS.Const.squares - 1;
      top = cell.y > 0;
      bottom = cell.y < AS.Const.squares - 1;
      if (left) {
        neighbors.push({
          x: x - 1,
          y: y,
          gScore: this.grid[x - 1][y],
          dad: cell
        });
      }
      if (right) {
        neighbors.push({
          x: x + 1,
          y: y,
          gScore: this.grid[x + 1][y],
          dad: cell
        });
      }
      if (top) {
        neighbors.push({
          x: x,
          y: y - 1,
          gScore: this.grid[x][y - 1],
          dad: cell
        });
      }
      if (bottom) {
        neighbors.push({
          x: x,
          y: y + 1,
          gScore: this.grid[x][y + 1],
          dad: cell
        });
      }
      if (this.diagonals) {
        if (left && top) {
          neighbors.push({
            x: x - 1,
            y: y - 1,
            gScore: this.grid[x - 1][y - 1],
            dad: cell
          });
        }
        if (left && bottom) {
          neighbors.push({
            x: x - 1,
            y: y + 1,
            gScore: this.grid[x - 1][y + 1],
            dad: cell
          });
        }
        if (right && top) {
          neighbors.push({
            x: x + 1,
            y: y - 1,
            gScore: this.grid[x + 1][y - 1],
            dad: cell
          });
        }
        if (right && bottom) {
          neighbors.push({
            x: x + 1,
            y: y + 1,
            gScore: this.grid[x + 1][y + 1],
            dad: cell
          });
        }
      }
      return neighbors;
    };

    Pathfinder.prototype.setSizes = function() {
      this.canvas.width = Math.min($(window).width() - 40, AS.Const.width);
      this.canvas.height = Math.min($(window).width() - 40, AS.Const.height);
      AS.Const.squareLen = this.canvas.width / AS.Const.squares;
    };

    Pathfinder.prototype.changeStart = function(x, y) {
      this.start.x = x;
      this.start.y = y;
    };

    Pathfinder.prototype.changeGoal = function(x, y) {
      this.goal.x = x;
      this.goal.y = y;
    };

    Pathfinder.prototype.increaseCellCost = function(x, y) {
      this.grid[x][y] += 200;
      if (this.grid[x][y] > 1000) {
        this.grid[x][y] = 1000;
      }
    };

    Pathfinder.prototype.disableButtons = function() {
      $('button').attr('disabled', 'disabled');
    };

    Pathfinder.prototype.enableButtons = function() {
      $('button').removeAttr('disabled');
    };

    Pathfinder.prototype.setEvents = function() {
      var keyCodes, modStatus,
        _this = this;
      modStatus = {
        none: 0,
        ctrl: 1,
        shift: 2
      };
      keyCodes = {
        ctrl: 17,
        shift: 16
      };
      this.keyMode = modStatus.none;
      this.enableButtons();
      this.diagonals = true;
      $('#diagonal').prop('checked', this.diagonals);
      $(this.canvas).bind('mousedown', function(e) {
        var i, j;
        i = Math.floor((e.pageX - _this.canvas.offsetLeft) / AS.Const.squareLen);
        j = Math.floor((e.pageY - _this.canvas.offsetTop) / AS.Const.squareLen);
        if (e.which === 1) {
          switch (_this.keyMode) {
            case modStatus.none:
              _this.changeStart(i, j);
              break;
            case modStatus.ctrl:
              _this.changeGoal(i, j);
              break;
            case modStatus.shift:
              _this.increaseCellCost(i, j);
          }
        } else if (e.which === 2) {
          _this.increaseCellCost(i, j);
        } else {
          _this.changeGoal(i, j);
        }
        _this.painter.drawAll();
        return false;
      });
      $(this.canvas).bind('contextmenu', function() {
        return false;
      });
      $(window).bind('keydown', function(e) {
        if (e.which === keyCodes.ctrl) {
          _this.keyMode = modStatus.ctrl;
        } else if (e.which === keyCodes.shift) {
          _this.keyMode = modStatus.shift;
        }
      });
      $(window).bind('keyup', function() {
        _this.keyMode = modStatus.none;
      });
      $('#instantSolve').bind('click', function() {
        _this.disableButtons();
        _this.AstarInit();
        while (_this.AstarLoop()) {}
        _this.enableButtons();
      });
      $('#diagonal').bind('click', function(ev) {
        _this.diagonals = ev.currentTarget.checked;
        return true;
      });
      $(window).resize(function() {
        _this.setSizes();
        _this.painter.drawAll();
      });
    };

    return Pathfinder;

  })();

  AS.MapGenerator = (function() {
    function MapGenerator() {}

    MapGenerator.prototype.buildMap = function(grid) {
      var i, j, _i, _j, _k, _ref, _ref1, _ref2;
      if (grid.length === 0) {
        for (i = _i = 0, _ref = AS.Const.squares; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          grid.push((function() {
            var _j, _ref1, _results;
            _results = [];
            for (j = _j = 0, _ref1 = AS.Const.squares; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              _results.push(10);
            }
            return _results;
          })());
        }
      } else {
        for (i = _j = 0, _ref1 = AS.Const.squares; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          for (j = _k = 0, _ref2 = AS.Const.squares; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; j = 0 <= _ref2 ? ++_k : --_k) {
            grid[i][j] = 10;
          }
        }
      }
      this.divideMap(grid, 0, 0, AS.Const.squares, AS.Const.squares, 0);
      return grid;
    };

    MapGenerator.prototype.decideOrientation = function(width, height) {
      if (width < height) {
        return 0;
      }
      if (height < width) {
        return 1;
      }
      return Math.floor(Math.random() * 2);
    };

    MapGenerator.prototype.divideMap = function(grid, x, y, width, height, orientaion) {
      var dx, dy, h, i, isHorizontal, len, nx, ny, val, w, wx, wy, _i;
      if (width < 4 || height < 6) {
        return;
      }
      isHorizontal = orientaion === 0;
      wx = x + (isHorizontal ? 0 : Math.floor(Math.random() * (width - 2)));
      wy = y + (isHorizontal ? Math.floor(Math.random() * (height - 2)) : 0);
      dx = isHorizontal ? 1 : 0;
      dy = isHorizontal ? 0 : 1;
      len = isHorizontal ? width : height;
      val = Math.floor(Math.random() * 1000);
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        grid[wx][wy] = val;
        wx += dx;
        wy += dy;
      }
      nx = x;
      ny = y;
      if (isHorizontal) {
        w = width;
        h = wy - y + 1;
      } else {
        w = wx - x + 1;
        h = height;
      }
      this.divideMap(grid, nx, ny, w, h, this.decideOrientation(w, h));
      if (isHorizontal) {
        nx = x;
        ny = wy + 1;
        w = width;
        h = y + height - wy - 1;
      } else {
        nx = wx + 1;
        ny = y;
        w = x + width - wx - 1;
        h = height;
      }
      this.divideMap(grid, nx, ny, w, h, this.decideOrientation(w, h));
    };

    return MapGenerator;

  })();

  AS.Painter = (function() {
    function Painter(grid, ctx) {
      this.grid = grid;
      this.ctx = ctx;
    }

    Painter.prototype.drawGrid = function() {
      var i, j, _i, _j, _ref, _ref1;
      for (i = _i = 0, _ref = AS.Const.squares; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = AS.Const.squares; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          this.drawCell(i, j, this.gToColor(this.grid[i][j]));
        }
      }
    };

    Painter.prototype.drawCell = function(x, y, color) {
      this.ctx.fillStyle = color;
      this.ctx.fillRect(x * AS.Const.squareLen, y * AS.Const.squareLen, AS.Const.squareLen, AS.Const.squareLen);
    };

    Painter.prototype.drawAll = function(start, goal) {
      this.drawGrid();
      this.drawCell(start.x, start.y, '#22F');
      this.drawCell(goal.x, goal.y, '#F00');
    };

    Painter.prototype.drawSolution = function(start, goal, solutionCell) {
      this.drawAll(start, goal);
      solutionCell = solutionCell.dad;
      while (solutionCell.dad) {
        this.drawCell(solutionCell.x, solutionCell.y, '#0F0');
        solutionCell = solutionCell.dad;
      }
    };

    Painter.prototype.gToColor = function(g) {
      var str;
      str = Math.floor(g * 255 / 1000).toString(16);
      return '#' + str + str + str;
    };

    return Painter;

  })();

  astarPathfinder = new AS.Pathfinder($('#simview'));

}).call(this);
